<#
.VERSION 1.0
1.0 - Initial release

.DESCRIPTION
This script checks log4j precense on the system it is executed on.
The checks performed are detailed within the script and nothing but the detailed actions are performed as part of the execution.

Place the script in a folder and execute the script elevated with administrative privileges, the script will create a subfolder where it will create the result files.
For remote execution on multiple systems, the script can be copied to Windows\Temp folder and executed there. Invoke-Command, Invoke-WmiMethod, use of psexec etc. or other means of remote execution should be valid.
Remember to copy back the results to some central location if executed remotely.
Please note that executing on multiple systems might have inpact on eventual underlaying infrastructure - make sure to execute in smaller batches accordingly.

Ensure that the disclaimer is read and understood before execution!

.NOTES
 Author: Truesec Cyber Security Incident Response Team
 Website: https://truesec.com/
 Created: 2021-12-12

 Compatibility: The script has been tested and verified on PowerShell version 3 and 5

 .DISCLAIMER
 Any of use of this script should be performed by qualified professionals with the necessary knowledge and skills to make independent conclusions.
 The script does not guarantee or in any way ensure, promise or indicate that after successful execution, a system can be declared as safe.
 The script should be used as a tool to help identify indicators of log4j precense on the system it is executed on.

#>

# Set WorkPath
$WorkPath = "$PSScriptRoot\log4j_check_result"

# Check if WorkPath folder exist, create if false
if (!(Test-Path -Path $WorkPath)) {
    New-Item $WorkPath -type directory
}

# Check if Temp folder exist, create if false
# Used for unpacking *.war and *.ear files
if (!(Test-Path -Path "$WorkPath\temp")) {
    New-Item "$WorkPath\temp" -type directory
}

# Get timestamp to use in naming of file with results
$TimeStamp = Get-Date -UFormat "%Y%m%d.%H%M%S"

# Start transcript
Start-Transcript $WorkPath\$($env:COMPUTERNAME)_PowerShellTranscript_$TimeStamp.txt

# Add FileSystem typ, to be used in UnZip, LookForLOG4JMatch and LookForNestedJar functions
Add-Type -AssemblyName System.IO.Compression.FileSystem

# Add Unzip function to also cover older versions of PowerShell
function UnZip {
    param([string]$zipfile, [string]$outpath)

    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipfile, $outpath)
}

# Add LookForLOG4JMatch function to list content in Java files (*.jar, *.war and *.ear) and look for "log4j", "jndilookup", "jndimanager" and "socketnode"
function LookForLOG4JMatch {
    param([string]$FileToCheck)

    $ZipFile = [io.compression.zipfile]::OpenRead("$FileToCheck")

    $Check = $ZipFile.Entries | Where-Object { $_.Name -match "log4j" -or $_.Name -match "jndilookup" -or $_.Name -match "jndimanager" -or $_.Name -match "socketnode" }

    $ZipFile.Dispose()
    
    $Check
}

# Add LookForNestedJar function to list nested "*.jar" files inside Java files (*.jar, *.war and *.ear)
function LookForNestedJar {
    param([string]$FileToCheck)

    $ZipFile = [io.compression.zipfile]::OpenRead("$FileToCheck")

    $Check = $ZipFile.Entries | Where-Object { $_.Name -match ".jar" }

    $ZipFile.Dispose()
    
    $Check
}

# Add Invoke-TSxLOG4J function to check for Java files and check for matches. Covers Java files (*.jar, *.war and *.ear), and nested "*.jar" files in one sublevel
function Invoke-TsXLOG4J {
    # Get all drives
    $Drives = Get-PSDrive -PSProvider FileSystem

    # Execute search, one drive at the time
    Foreach ($Drive in $Drives) {
        
        # Write to host for transcript reason
        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Searching on $($Drive.name) this will take a few minutes..." -ForegroundColor Yellow

        # Find all Java files (*.jar, *.war and *.ear) and store in a variable
        $JavaFiles = Get-ChildItem $Drive.Root -Recurse -Force -Include *.jar, *.war, *.ear -ErrorAction SilentlyContinue -Verbose

        # Write to host for transcript reason
        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Done searching on $($Drive.name)" -ForegroundColor Yellow

        # Execute search for matches, one Java file at the time
        foreach ($JavaFile in $JavaFiles) {
            
            # Write filename to COMPUTERNAME_java_files_TIMESTAMP.txt
            $JavaFile.FullName | Out-File -Append -Encoding utf8 -FilePath $WorkPath\$($env:COMPUTERNAME)_java_files_$TimeStamp.txt

            # Write to host for transcript reason
            Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Checking $JavaFile" -ForegroundColor Yellow
            
            # Check Java file and write to file if there's a match
            if (LookForLOG4JMatch -FileToCheck $JavaFile) {

                # Write to host for transcript reason
                Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Positive indication found, writing to $($env:COMPUTERNAME)_matches_$TimeStamp.txt" -ForegroundColor Yellow
                
                # Write filename to COMPUTERNAME_matches_TIMESTAMP.txt
                $JavaFile.FullName | Out-File -Append -Encoding utf8 -FilePath $WorkPath\$($env:COMPUTERNAME)_matches_$TimeStamp.txt
            }

            # Check the Java file for nested "*.jar" files, unpack if nested file is found and check file and write to file if there's a match
            if (LookForNestedJar -FileToCheck $JavaFile) {

                # Write to host for transcript reason
                Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Found nested jar file inside $JavaFile" -ForegroundColor Yellow
                Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Temporary unpacking $JavaFile to $WorkPath\temp\File_Inside_$($JavaFile.basename)_$($($JavaFile.Extension).Substring(1))\ - to search recurse one level down in the file, this might take a few minutes..." -ForegroundColor Yellow

                # Unpack Java file that contained nested "*.jar" file to temparary folder
                UnZip -zipfile $JavaFile -outpath $WorkPath\temp\File_Inside_$($Drive.Name)_$($JavaFile.basename)_$($($JavaFile.Extension).Substring(1))\

                # Write to host for transcript reason
                Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Checking Inside $JavaFile for nested files" -ForegroundColor Yellow

                # Get all nested "*.jar" files in temporary folder
                $NestedFiles = Get-ChildItem $WorkPath\temp\ -Recurse -Force -Include *.jar, *.war, *.ear -ErrorAction SilentlyContinue -Verbose

                # Execute search for matches, one Java file at the time
                foreach ($NestedFile in $NestedFiles) {

                    # Check Java file and write to file if there's a match
                    if (LookForLOG4JMatch $NestedFile) {

                        # Write to host for transcript reason
                        Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Positive indication found in nested file $NestedFile.FullName, writing to $($env:COMPUTERNAME)_matches_$TimeStamp.txt" -ForegroundColor Yellow
                        
                        # Write filename to COMPUTERNAME_matches_TIMESTAMP.txt
                        $NestedFile.FullName | Out-File -Append -Encoding utf8 -FilePath $WorkPath\$($env:COMPUTERNAME)_matches_$TimeStamp.txt
                    }
                   
                }
                # Write to host for transcript reason
                Write-Host "$((Get-Date -UFormat "%Y%m%d.%H%M%S")) - Removing temporary folder $WorkPath\temp\File_Inside_$($Drive.Name)_$($JavaFile.basename)_$($($JavaFile.Extension).Substring(1))\, this might take a few minutes..." -ForegroundColor Yellow

                # Delete unpacked temp folder
                Remove-Item $WorkPath\temp\File_Inside_$($Drive.Name)_$($JavaFile.basename)_$($($JavaFile.Extension).Substring(1))\ -Recurse -Force
            }


        }
            
             
    }

      
}

# Run Invoke-TSxLOG4J function
Invoke-TSxLOG4J

# Remove Temp folder
Remove-Item $WorkPath\temp -Recurse -Force

# End transcript
Stop-Transcript